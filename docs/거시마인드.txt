* (?)이 없어질 때 까지 공부할 것

* 리액트 독스에서 테스트 대상으로 나열한 것들

- 설정/해제
컴포넌트 테스트할 때 각 유닛마다 before, after에서 설정해제 잘해서 독립성 유지하라는 얘기

- act()
렌더링, 이벤트, 데이터 가져오기 등 UI와 상호작용하는 각 단위 => 테스팅 라이브러리를 쓰면 사용하지 않을 메소드 어쩄건 이 메소드는 유닛을 의미함.

- 렌더링
컴포넌트 props받아 렌더링 -> 유닛 테스트
유저케이스에서 시나리오의 결과로 나타나는 렌더링 -> 통합 테스트

- 데이터 가져오기
서버에서 데이터를 가져오는게 아니라 더미데이터를 이용하기. => 즉, 테스트는 서버와의 의존성이 없어야함.

- 모듈 모의하기
일부 모듈은 테스트 환경에서 제대로 작동하지 않거나 테스트 자체에 필수적이지 않을수 있다. 그래서 이런 모듈을 더미 모듈로 대체(mock)한다. 
=> 모듈을 mock해야할지 말아야할지에 대한 판단 기준 = 테스트의 대상이 아닌 모듈은 mock을 한다.(?) 서버는 테스트 대상이 아니기에 mock한다.

- 이벤트
이벤트 발생시키고 그 결과를 테스트 -> 유저케이스별로 통합테스트

- 타이머
mock 타이머를 쓸 수 있다는 내용

- 스냅샷 테스트
필요없다봄

- 다수의 렌더러


* 마인드 정리

** 어떤 것에 대해 어떤 테스트를 할지 고민 내용 

- 아토믹 디자인식 개발을 가정하면 컴포넌트 하나만들때마다 컴포넌트 별 유닛 테스트를 만드는 것은 필요함. (컴포넌트 props, rendering)
- 공용 함수등 주요 로직을 담당하는 함수를 개발할 때에도 해당 함수에 대한 유닛테스트가 필요함. (jest로 함수에 대해 input -> output)
- 유저케이스에 대해서는 기능테스트가 필요함. 유저케이스는 event fire => 콜백 => 로직 => 데이터 변화 => 리렌더링 과 같은 절차가 있음. 
event fire자체는 유닛테스트가 의미없음. 
event 콜백 함수는 독립 함수로 분리된 경우 유닛테스트를 만듬.
로직, 데이터 변화, 리렌더링은 상호작용의 결과물이므로 유닛테스트가 불가능함. (cypress functional test)
- api등 server와 상호작용하는 것에 대해서는 어떤 테스트를? 테스트는 서버와의 의존성이 없어야 하므로 리퀘스트에 대한 응답은 더미데이터를 활용한다. 
그래서 어떤 요청에 대해 어떤 응답데이터가 온다는 것은 테스트 대상이 아니다. (stub)
- 리덕스에 대해서 (dispatch -> create action -> reducer -> update store -> rerendering): 
dispatch, create action, update store에 대한 유닛 테스트는 무의미. reducer함수에 대해 유닛테스트는 유의미. 
그외 리덕스 flow(중간에 서버와의 통신이 들어가든 말든) 전체에 대해서는 통합 테스트를 함 
(jest reducer에 대해 unit, 리덕스 플로우에 대해서는 cypress functional test)

** 유닛 테스트

- 유닛의 단위: 컴포넌트, 함수
- 유닛 테스트 조직화: 준비 - 실행 - 단언

*** 아톰 컴포넌트 유닛 테스트

- 컴포넌트 임포트 (준비)
컴포넌트를 임포트하는 순간 컴포넌트 안에서 서버에 호출하는 코드가 있으면 서버에 리퀘스트를 날려버리기 때문에 실제서버가 동작해버리는데 이것은 문제가 되는지(?)
문제가 된다면 어떻게 해결해야하는지(?)

- dummy props 선언 (준비)

- 컴포넌트 마운트 (실행)
dummy props를 받는 컴포넌트가 마운트됨.

- 컴포넌트 렌더링 (단언)
dummy props에 따라 기대되는 렌더링을 테스트한다.

- 컴포넌트 언마운트 (실행)
각 유닛 테스트가 끝날 때마다 컴포넌트는 언마운트 해야한다.

*** 함수 유닛 테스트

- 유닛 테스트 대상 함수의 종류: 이벤트 핸들러, 리듀서 등 콜백함수, 각종 로직에서 사용되는 모듈화된 함수

- 함수 임포트 (준비)
모듈화된 함수는 임포트하기 편한 디렉토리에 위치해야만 한다.

- 더미 인수(arguments) 선언 (준비)
파라미터에 넘겨줄 더미 데이터를 선언

- 함수 실행 (실행)
더미 인수로 함수를 실행

- 함수 리턴 결과값 (단언)

** 통합 테스트 (컴포넌트 통합 테스트, 기능 테스트, 유저 시나리오 테스트)

- 통합 테스트? 기능 테스트?
cypress로 유저 시나리오에 대해 e2e 테스트를 하는 것은 기능 테스트라고 부른다.
앞서 유닛 테스트로 각 컴포넌트와 함수를 테스트했고 기능 테스트를 위해서 각 단위 모듈들을 통합해서 테스트 해야하기에 통합 테스트에도 속하는것 같다.
통합 테스트는 유닛 테스트를 통합해가는 과정을 통합 테스트라고 하는 것일까(?)
그리고 기능 테스트는 통합 테스트에 속하는 것일까(?)

- 통합 테스트 방법
빅뱅 접근법, 상향식 통합 접근법, 하향식 통합 접근법, 샌드위치식 통합 접근법

*** 컴포넌트 통합 테스트 (상향식 통합)

아톰 컴포넌트들은 유닛테스트를 했다.
아톰들을 조합하여 상위 컴포넌트를 만들어나간다.
이것을 상향식 통합 테스트로 한다.

**** 예를 들어 아톰 A, B가 개발되었을 때 이들을 조립한 상위 컴포넌트 C에 대해 테스트한다.

- 컴포넌트 C 임포트 (준비)

- dummy props 선언 (준비)

- 컴포넌트 마운트 (실행)
dummy props를 받는 컴포넌트가 마운트됨.

- 컴포넌트 렌더링 (단언)
dummy props에 따라 기대되는 렌더링을 테스트한다.

- 컴포넌트 언마운트 (실행)

*** 유저 시나리오 테스트 (기능 테스트, 하향식 통합(?))

- 테스트 코드 및 본 코드 개발 시점
각 유저 시나리오는 다음과 같은 로직으로 구성된다.
event fire => 콜백(유닛 테스트) => 로직 => 데이터 변화 => 리렌더링

컴포넌트, 함수로 분류해보면
컴포넌트: event fire (atom에 가까운 작은 단위의 컴포넌트일 확률이 높음), 리렌더링(state가 선언된 컴포넌트부터 그 하위 컴포넌트들)
함수: 이벤트 핸들러, 리듀서 => 이들은 setState를 가진다고 가정(리렌더링까지 포함해 생각하기 위해)

따라서 유저 시나리오와 관련된 state가 선언된 컴포넌트들 중 가장 상위 컴포넌트에서 테스트한다.
그런데 컴포넌트 개발은 아토믹 디자인으로 상향식 통합으로 하기 때문에 기본적으로 인터페이스 기반으로한 컴포넌트 렌더링 유닛 개발이 다 이루어진 상태에서
유저 시나리오 개발이 들어가야한다.

- 개발 순서
- 메인 시나리오 케이스 (e2e)
전제: 필요한 컴포넌트 렌더링 유닛 개발과 콜백 유닛 함수 개발은 이미 되었어야 한다.
1. 필요한 API, UI 등 인터페이스, 콜백함수 명세를 만든다.
2. 필요한 더미 데이터를 만든다.
3. 유닛 테스트: 콜백함수
(이상 준비)
4. 시나리오 기능 테스트
UI셋업(준비)하고 이벤트 발생시키고(실행) (중간에 API 통신 있을수도) 기대하는 데이터 변경값과 리렌더링값을 테스트한다.(단언)
5. 중간에 API 통신이 있는 경우는 아래의 ajax 테스트를 이벤트 발생 이후 API호출 단계에 넣어야함.

- 부가, 에외 시나리오 케이스
-- 메인 시나리오 케이스에서(지금껏 작성한 시나리오 케이스 중에서) 커버가 되지 않은 UI 요구사항이 있으면 UI 셋업부터 해서 위 개발순서를 반복 (e2e test)
-- 작성한 시나리오 케이스 중에서 커버가 된 UI요구사항이면 해당 UI셋업과 이벤트발생은 생략하고 API request부터 테스트를 진행 (shortcuts test)

*** ajax 테스트 (기능 테스트, 하향식 통합(?))

- 개발 순서
1. 필요한 API, 인터페이스, 콜백함수 명세를 만든다.
2. 더미 리퀘스트, 리스폰스 데이터 생성
(이상 준비)
3. 컴포넌트 라이프 사이클, 혹은 이벤트 발생에 따라 적절한 시점에 request 쏘는지 테스트 (유닛테스트, 실행, 단언)
4. 서버 의존을 하면 안되므로 더미 응답데이터를 받을 때 이후 로직 실행(유닛테스트를 마친 함수를 실행, 실행) 그리고 기대하는 데이터 변경값과 리렌더링값을 테스트 (단언)

*** redux 테스트 (기능 테스트, 하향식 통합(?))

- 개발 순서
1. 필요한 API, 인터페이스, 콜백함수, 리덕스 플로우 명세를 만든다.
2. 리듀서 콜백함수 유닛테스트 및 개발 완료
3. payload 더미 데이터 생성
(이상 준비)
4. payload와 함께 action dispatch (실행), (중간에 API 통신 있을 수도) 스토어 업데이트 데이터값 확인 (단언), 리렌더링 확인(단언)
5. 중간에 API 통신이 있는 경우는 위의 ajax 테스트를 액션생성 이후 API호출 단계에 넣어야함.
