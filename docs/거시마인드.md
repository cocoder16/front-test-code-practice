# 리액트 독스에서 테스트 대상으로 나열한 것들

- 설정/해제

컴포넌트 테스트할 때 각 유닛마다 before, after에서 설정해제 잘해서 독립성 유지하라는 얘기

- act()

렌더링, 이벤트, 데이터 가져오기 등 UI와 상호작용하는 각 단위 <br />
=> 테스팅 라이브러리를 쓰면 사용하지 않을 메소드 어쩄건 이 메소드는 유닛을 의미함.

- 렌더링

컴포넌트 props받아 렌더링 => TDD 유닛 테스트 <br />
유저케이스에서 시나리오의 결과로 나타나는 렌더링 => BDD 기능 테스트

- 데이터 가져오기

서버에서 데이터를 가져오는게 아니라 더미데이터를 이용하기. <br />
=> 즉, 테스트는 서버와의 의존성이 없어야함.

- 모듈 모의하기

일부 모듈은 테스트 환경에서 제대로 작동하지 않거나 테스트 자체에 필수적이지 않을수 있다. 그래서 이런 모듈을 더미 모듈로 대체(mock)한다.

> - 모듈을 mock해야할지 말아야할지에 대한 판단 기준 <br />
>   => 테스트의 대상이 아닌 모듈은 mock을 한다.서버는 테스트 대상이 아니기에 mock한다.

- 이벤트

이벤트 발생시키고 그 결과를 테스트 <br />
=> 유저케이스별로 기능테스트

- 타이머

mock 타이머를 쓸 수 있다는 내용

- 스냅샷 테스트

필요없다봄

- 다수의 렌더러

* 마인드 정리

# 어떤 것에 대해 어떤 테스트를 할지 고민 내용

## 아토믹 디자인식 컴포넌트 개발 => 컴포넌트 하나만들때마다 컴포넌트 별 유닛 테스트

### 컴포넌트 유닛테스트 내용

- 인터페이스 테스트 (TDD)

> Given) props 값에 따라서<br/>
> Then) 기대되는 초기 렌더링 테스트

- 공용 함수등 주요 로직을 담당하는 함수를 개발할 때에도 해당 함수에 대한 유닛테스트가 필요함. (TDD)

> (함수에 대해 input -> output)

- 유즈 케이스에 대해서는 기능테스트가 필요함. (BDD) <br />
  **이것은 컴포넌트 유닛테스트와 통합테스트에서의 기능테스트 모두 해당하는 내용이다.**

> - 유즈케이스는 event fire => 콜백 => 로직 => 데이터 변화 => 리렌더링 과 같은 절차가 있음. <br />
>   event fire자체는 유닛테스트가 의미없음. (BDD에서 When에 해당) <br />
>   event 콜백 함수는 독립 함수로 분리된 경우 유닛테스트를 만듬. (TDD) <br />
>   로직, 데이터 변화, 리렌더링은 상호작용의 결과물이므로 BDD

> - BDD 테스트 하나에 들어갈 내용<br />
>   Given) props와 함께, 컴포넌트 mount (e2e라면, visit url) <br />
>   When) 해당 컴포넌트가 가진 UI에 대해 유저가 할 수 있는 모든 행동별로 테스트 케이스를 만든다. (e2e라면, 컴포넌트 유닛테스트로 커버할 수 없었던 유즈 시나리오에 대해 케이스를 만든다.)<br />
>   Then) UI에 대해 유저가 행동한 후 기대되는 데이터값과 리렌더링 결과를 단언

> - api등 server와 상호작용하는 것에 대해서는 테스트 내에서 어떻게 대응해야할지? <br />
>   테스트는 서버와의 의존성이 없어야 하므로 리퀘스트에 대한 응답은 더미데이터를 활용한다. (stub)
>   그래서 어떤 요청에 대해 어떤 응답데이터가 온다는 것은 테스트 대상이 아니다. 선언해놓고 사용하는 것이다.

## 리덕스 테스트

**리덕스 flux 패턴: dispatch -> create action -> reducer -> update store -> view(re-rendering)**

dispatch, create action, update store에 대한 유닛 테스트는 무의미. <br />
reducer함수에 대해 유닛테스트는 유의미. 하다고 내 스스로 판단함. <br />
그 외 리덕스 flow (중간에 서버와의 통신이 들어가든 말든) 전체에 대해서는 통합 테스트 BDD로 커버함 (이것도 내가 스스로 효율적이라고 판단한 패턴) <br />
즉, reducer에 대해 unit test, 리덕스 플로우에 대해서는 functional test

# 유닛테스트

- 유닛의 단위: 컴포넌트, 함수
- 유닛 테스트 조직화: 준비 - 실행 - 단언
- TDD 커밋단위:

1. 테스트 작성 -> 본 코드 작성 -> 리팩토링 -> 커밋
2. 리팩토링 -> 테스트 통과확인 -> 커밋

## reference:

### 컴포넌트 유닛 테스트

- https://docs.cypress.io/guides/component-testing/introduction#What-is-Component-Testing
- https://www.cypress.io/blog/2021/04/06/cypress-component-testing-react/
- https://github.com/lmiller1990/cypress-react-template

- 절차

1. 컴포넌트 임포트 (준비)

컴포넌트를 임포트하는 순간 컴포넌트 안에서 서버에 호출하는 코드가 있으면 서버에 리퀘스트를 날려버리기 때문에 실제서버가 동작해버리는데 이것은 문제가 되는지? <br />
문제가 된다면 어떻게 해결해야하는지? <br />

=> cypress 문서에 의하면 문제가 되지 않는다. cypress는 실제 백엔드 API 서버를 켜놓고 테스트하는 것을 디폴트로 디자인하였다. 하지만, 백엔드 서버가 존재하지 않아도 서버를 mocking하여 테스트하는 것이 가능하고 나는 이 방법이 더 좋아보인다. 백엔드와의 의존성이 없는 상태에서 개발이 가능하기 때문이다. cypress에서는 백엔드 API 서버를 mocking 해서 띄워놓지 않고 intercept()라는 메소드를 통해 http 리퀘스트를 가로채서 실제 서버까지 요청이 도달하지 않아도 stub된 resposne를 뿌려줄 수 있다. 이 방법으로 실제 서버로 날리는 리퀘스트는 실제 서버에 도달하지 않게 되며, response도 stub data를 사용할 수 있게 된다.

2. dummy props 선언 (준비)

3. 컴포넌트 마운트 (실행)

dummy props를 받는 컴포넌트가 마운트됨.

4. 컴포넌트 렌더링 (단언)

dummy props에 따라 기대되는 렌더링을 테스트한다.

5. 인터페이스 테스트 (실행, 단언)

html태그의 기능을 테스트.(아톰인 경우) <br />
dummy props들 중 인터페이스 역할을 하는 것들을 스텁하여 호출횟수를 테스트.

6. 기능테스트 (실행, 단언)

컴포넌트 내에 정의된 함수들은 유닛테스트를 하지 않고 사용자 시나리오를 기반으로한 BDD로 기능테스트를 작성

7. 컴포넌트 언마운트 (실행)
   각 유닛 테스트가 끝날 때마다 컴포넌트는 언마운트 해야한다.

### 함수 유닛 테스트

- https://github.com/cypress-io/cypress-example-recipes/tree/master/examples/unit-testing__application-code

- 유닛 테스트 대상 함수의 종류: 이벤트 핸들러, 리듀서 등 콜백함수, 각종 로직에서 사용되는 모듈화된 함수 (컴포넌트 내에 선언된 함수는 모듈화가 안된 것으로 보아 유닛테스트 대상이 아니라, 컴포넌트 기능테스트로 커버해야할 함수로 분류)

- 절차

1. 함수 임포트 (준비)
   모듈화된 함수는 임포트하기 편한 디렉토리에 위치해야만 한다.

2. 더미 인수(arguments) 선언 (준비)
   파라미터에 넘겨줄 더미 데이터를 선언

3. 함수 실행 (실행)
   더미 인수로 함수를 실행

4. 함수 리턴 결과값 (단언)

# 통합 테스트 (컴포넌트 통합 테스트, 기능 테스트, 유저 시나리오 테스트)

## 통합 테스트? 기능 테스트?

cypress로 유저 시나리오에 대해 e2e 테스트를 하는 것은 기능 테스트라고 부른다.
앞서 유닛 테스트로 각 컴포넌트와 함수를 테스트했고 유닛 테스트 안에 속하는 기능 테스트도 있었다. 각 유닛을 통합한 상태인 브라우저에서 동작하는 테스트를 통합 테스트라고 할 수 있다. <br />
통합 테스트의 사전적 정의는 유닛 테스트를 마친 모듈들을 연동한 상태에서 잘 작동하는지 테스트 하는 것이다.

## 통합 테스트 방법

빅뱅 접근법, 상향식 통합 접근법, 하향식 통합 접근법, 샌드위치식 통합 접근법

## 컴포넌트 통합 테스트 (상향식 통합)

아톰 컴포넌트들은 유닛테스트를 했다. <br />
아톰들을 조합하여 상위 컴포넌트를 만들어나간다. <br />
이것을 상향식 통합 테스트로 한다.

**그래서 사실 하위 컴포넌트를 임포팅하여 사용하는 모든 컴포넌트에 대한 유닛테스트는 통합테스트이기도 하다.**
프론트엔드에서 통합테스트와 유닛테스트의 경계가 모호하다고 느끼는 것은 이것 때문이다.

### 예를 들어 아톰 A, B가 개발되었을 때 이들을 조립한 상위 컴포넌트 C에 대해 테스트한다.

- 위에서 정리한 컴포넌트 유닛테스트와 동일하게 실행을 한다.
- 단, A, B 컴포넌트의 유닛테스트에서 커버한 내용은 다시 테스트할 필요가 없다. 즉, A, B가 가진 내용에 대해서는 테스트하지말 것
- 이것은 컴포넌트 C에 대한 유닛 테스트이면서, 동시에 컴포넌트 상향식 통합 테스트이기도 한 것이다.

## 유저 시나리오 테스트 (기능 테스트, 상향식 통합)

### 테스트 코드 및 본 코드 개발 시점

각 유저 시나리오는 다음과 같은 로직으로 구성된다.

```
event fire => 콜백 => 로직 => (리덕스), (ajax) => 데이터 변화 => 리렌더링
```

- 따라서 유저 시나리오와 관련된 state가 선언된 컴포넌트들 중 가장 상위 컴포넌트에서 테스트한다.
- App(server) - pages(routes) - features - domains - components 구성의 레이어를 가진 경우, features 레이어까지 통합이 되었으면, 이때부터는 BDD를 컴포넌트 유닛 테스트가 아니라, e2e에서 하는 것이 좋아보인다. components부터 domains 레이어까지는 유닛 테스트에서 BDD로 기능 테스트를 커버하는게 좋아보인다.

# 부가, 에외 시나리오 케이스

예외처리, catch문 처리에 대한 테스트는 유닛, 기능 테스트 모두에서 요구사항에 따라 적용된다.

## 부가 시나리오 테스트

같은 UI, 같은 모듈에 대해 메인 테스트 케이스를 작성한 이후에, 2번째, 3번째 부가 케이스를 작성할 때에는

1. 동일한 셋업은 리팩토링하여 중복을 제거한다.
2. 중복된 단언을 하지 않는다. (전 케이스에서 이미 통과한 로직은 또 테스트할 필요가 없다.)

# ajax 테스트

redux-thunk 테스트 (docs에서는 고립적인 유닛 테스트를 권장하지 않고, 기능 테스트를 권장함.) <br />
=> 같은 결로 액션 생성 함수도 유닛 테스트를 할 필요가 없다고 느낌.

docs: https://ko.redux.js.org/recipes/writing-tests <br />
We consider thunk behavior to be an implementation detail of the application,
and recommend that it be covered by testing the group of components (or whole app) using it, rather than testing the thunk in isolation.

결론적으로, e2e 테스트로 커버하며, cy.intercept() 메소드를 이용한 stub을 활용한다.
